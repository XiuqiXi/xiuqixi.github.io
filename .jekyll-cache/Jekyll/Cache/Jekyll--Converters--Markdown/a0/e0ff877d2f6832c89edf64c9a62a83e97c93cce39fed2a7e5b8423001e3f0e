I"øB<aside class="sidebar__right">
<nav class="toc">
    <header><h4 class="nav__title"><i class="fa fa-file-text"></i> Contents</h4></header>
<ul class="toc__menu" id="markdown-toc">
  <li><a href="#exercises-of-chapter-1" id="markdown-toc-exercises-of-chapter-1">Exercises of Chapter 1<a id="sec-1"></a></a>    <ul>
      <li><a href="#11" id="markdown-toc-11">1.1<a id="sec-1-1"></a></a></li>
      <li><a href="#12" id="markdown-toc-12">1.2<a id="sec-1-2"></a></a></li>
      <li><a href="#13" id="markdown-toc-13">1.3<a id="sec-1-3"></a></a></li>
      <li><a href="#14" id="markdown-toc-14">1.4<a id="sec-1-4"></a></a></li>
      <li><a href="#15" id="markdown-toc-15">1.5<a id="sec-1-5"></a></a></li>
      <li><a href="#16" id="markdown-toc-16">1.6<a id="sec-1-6"></a></a></li>
      <li><a href="#17" id="markdown-toc-17">1.7<a id="sec-1-7"></a></a>        <ul>
          <li><a href="#how-floating-point-numbers-work" id="markdown-toc-how-floating-point-numbers-work">How floating-point numbers work<a id="sec-1-7-1"></a></a></li>
        </ul>
      </li>
      <li><a href="#18" id="markdown-toc-18">1.8<a id="sec-1-8"></a></a></li>
      <li><a href="#19" id="markdown-toc-19">1.9<a id="sec-1-9"></a></a></li>
      <li><a href="#110" id="markdown-toc-110">1.10<a id="sec-1-10"></a></a></li>
      <li><a href="#111" id="markdown-toc-111">1.11<a id="sec-1-11"></a></a></li>
      <li><a href="#112" id="markdown-toc-112">1.12<a id="sec-1-12"></a></a></li>
      <li><a href="#113" id="markdown-toc-113">1.13<a id="sec-1-13"></a></a></li>
      <li><a href="#114" id="markdown-toc-114">1.14<a id="sec-1-14"></a></a></li>
      <li><a href="#115" id="markdown-toc-115">1.15<a id="sec-1-15"></a></a></li>
      <li><a href="#116" id="markdown-toc-116">1.16<a id="sec-1-16"></a></a></li>
      <li><a href="#117" id="markdown-toc-117">1.17<a id="sec-1-17"></a></a></li>
      <li><a href="#118" id="markdown-toc-118">1.18<a id="sec-1-18"></a></a></li>
      <li><a href="#119" id="markdown-toc-119">1.19<a id="sec-1-19"></a></a></li>
      <li><a href="#120" id="markdown-toc-120">1.20<a id="sec-1-20"></a></a></li>
      <li><a href="#121" id="markdown-toc-121">1.21<a id="sec-1-21"></a></a></li>
      <li><a href="#122" id="markdown-toc-122">1.22<a id="sec-1-22"></a></a></li>
      <li><a href="#123" id="markdown-toc-123">1.23<a id="sec-1-23"></a></a></li>
      <li><a href="#124" id="markdown-toc-124">1.24<a id="sec-1-24"></a></a></li>
      <li><a href="#125" id="markdown-toc-125">1.25<a id="sec-1-25"></a></a></li>
      <li><a href="#126" id="markdown-toc-126">1.26<a id="sec-1-26"></a></a></li>
      <li><a href="#127" id="markdown-toc-127">1.27<a id="sec-1-27"></a></a></li>
      <li><a href="#128" id="markdown-toc-128">1.28<a id="sec-1-28"></a></a></li>
      <li><a href="#129" id="markdown-toc-129">1.29<a id="sec-1-29"></a></a></li>
      <li><a href="#130" id="markdown-toc-130">1.30<a id="sec-1-30"></a></a></li>
      <li><a href="#131" id="markdown-toc-131">1.31<a id="sec-1-31"></a></a></li>
      <li><a href="#132" id="markdown-toc-132">1.32<a id="sec-1-32"></a></a></li>
      <li><a href="#133" id="markdown-toc-133">1.33<a id="sec-1-33"></a></a></li>
      <li><a href="#134" id="markdown-toc-134">1.34<a id="sec-1-34"></a></a></li>
      <li><a href="#135" id="markdown-toc-135">1.35<a id="sec-1-35"></a></a></li>
      <li><a href="#136" id="markdown-toc-136">1.36<a id="sec-1-36"></a></a></li>
      <li><a href="#137" id="markdown-toc-137">1.37<a id="sec-1-37"></a></a></li>
      <li><a href="#138" id="markdown-toc-138">1.38<a id="sec-1-38"></a></a></li>
      <li><a href="#139" id="markdown-toc-139">1.39<a id="sec-1-39"></a></a></li>
      <li><a href="#140" id="markdown-toc-140">1.40<a id="sec-1-40"></a></a></li>
      <li><a href="#141" id="markdown-toc-141">1.41<a id="sec-1-41"></a></a></li>
      <li><a href="#142" id="markdown-toc-142">1.42<a id="sec-1-42"></a></a></li>
      <li><a href="#143" id="markdown-toc-143">1.43<a id="sec-1-43"></a></a></li>
      <li><a href="#144" id="markdown-toc-144">1.44<a id="sec-1-44"></a></a></li>
      <li><a href="#145" id="markdown-toc-145">1.45<a id="sec-1-45"></a></a></li>
      <li><a href="#146" id="markdown-toc-146">1.46<a id="sec-1-46"></a></a></li>
    </ul>
  </li>
</ul>

  </nav>
</aside>

<h1 id="exercises-of-chapter-1">Exercises of Chapter 1<a id="sec-1"></a></h1>

<h2 id="11">1.1<a id="sec-1-1"></a></h2>

<p>Omit.</p>

<h2 id="12">1.2<a id="sec-1-2"></a></h2>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">5</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)))))</span>
   <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">6</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">2</span> <span class="mi">7</span><span class="p">)))</span>
</code></pre></div></div>

<h2 id="13">1.3<a id="sec-1-3"></a></h2>

<p>Define a procedure that take three numbers as arguments and returns the sum of the squares of the two larger numbers.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">square-sum-large-two</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">c</span> <span class="nv">b</span><span class="p">))</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
        <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">a</span> <span class="nv">c</span><span class="p">))</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
        <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">a</span> <span class="nv">c</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">=</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">=</span> <span class="nv">a</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">=</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">square-sum</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
        <span class="p">))</span>

<span class="p">(</span><span class="nf">square-sum-large-two</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="14">1.4<a id="sec-1-4"></a></h2>

<p>Observe that our model of evaluation allows for combinations whose operators are compound expressions.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">a-plus-abs-b</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">((</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">+</span> <span class="nv">-</span><span class="p">)</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="15">1.5<a id="sec-1-5"></a></h2>

<p>Determine whether interpreter is using applicative-order evaluation or normal-order evaluation. There are two procedures defined as follows:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span> <span class="nv">y</span><span class="p">))</span>
<span class="c1">;; then evaluate the expression</span>
<span class="p">(</span><span class="nf">test</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>
</code></pre></div></div>

<p>What behavior will be observed with an interpreter that uses applicative-order evaluation? What behavior will be observed with an interpreter that uses normal-order evaluation? (Assume that the evaluation rule for the special form <code class="language-plaintext highlighter-rouge">if</code> is the same for both cases: the predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression).</p>

<p>The normal-order will fully expand and notice the predicate is true and return 0; However, the applicative-order will try to evaluate <code class="language-plaintext highlighter-rouge">(p)</code> first and apply that, but it is a recursive call to <code class="language-plaintext highlighter-rouge">(p)</code> itself, so, following this rule, it ends up with an infinite loop.</p>

<h2 id="16">1.6<a id="sec-1-6"></a></h2>

<p>Why <code class="language-plaintext highlighter-rouge">if</code> has to be a special form?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">new-if</span> <span class="nv">predicate</span> <span class="nv">then-clause</span> <span class="nv">else-clause</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">(</span><span class="nf">predicate</span> <span class="nv">then-clause</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else</span> <span class="nv">else-clause</span><span class="p">)))</span>
</code></pre></div></div>

<p>Delighted, Alyssa uses <code class="language-plaintext highlighter-rouge">new-if</code> to rewrite the square-root program:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">new-if</span> <span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
          <span class="nv">guess</span>
          <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
                     <span class="nv">x</span><span class="p">)))</span>
</code></pre></div></div>

<p>What happens when Alyssa attempts to use this to compute square roots? Explain.</p>

<p>Because the <code class="language-plaintext highlighter-rouge">new-if</code> is not a special form, so the subexpressions need to be evaluated before we can apply the <code class="language-plaintext highlighter-rouge">new-if</code> to the operands. However, the third formal parameter is a recursive call to <code class="language-plaintext highlighter-rouge">sqrt-iter</code>, which will lead to infinite evaluation loop for sub-expressions. A dead loop.</p>

<h2 id="17">1.7<a id="sec-1-7"></a></h2>

<p>The <code class="language-plaintext highlighter-rouge">good-enough?</code> test used in computing square roots will not be very effective for finding the square roots of very small numbers. Also, in real computers, arithmetic operations are almost always performed with limited precision. This makes our test inadequate for very large numbers. Explain these statements, with examples showing how the test fails for small and large numbers.</p>

<p>An alternative strategy for implementing <code class="language-plaintext highlighter-rouge">good-enough?</code> is to watch how guess changes from one iteration to the next and to stop when the change is a very small fraction of the guess.</p>

<p>Design a square-root procedure that uses this kind of end test. Does this work better for small and large</p>

<p>A: For very small numbers: assume \(t\) is the tolerance we set for the <code class="language-plaintext highlighter-rouge">good-enough?</code> procedure, and \(\varepsilon\) is a very small number that is smaller than the tolerance we set. When the guess approaches to a point where \(guess^2 &lt; (t + \varepsilon)\), than the absolute difference between \(guess^2\) and \(\varepsilon\) is always in the tolerance range but the \(guess\) right now is not necessary the right answer. Example (small number): Let \(\varepsilon = 0.0000001\), start \(guess\) from 1.0.</p>

<p>For very large numbers, what will happen if the arithmetic operations are performed with limited precision? For large numbers, when the precision digits runs out, we might get stuck at a number which is not the answer but we are not able to proceed because the <code class="language-plaintext highlighter-rouge">good-enough?</code> procedure is unable to tell the difference because of precision overflow. Then the procedure will continue forever without convergence.</p>

<h3 id="how-floating-point-numbers-work">How floating-point numbers work<a id="sec-1-7-1"></a></h3>

<p>The idea is to compose a number of two main parts:</p>

<ul>
  <li>A <strong>significand</strong> that contains the numberâs digits. Negative significands represent negative numbers.</li>
  <li>An <strong>exponent</strong> that says where the decimal (or binary) point is placed relative to the beginning of the significand. Negative exponents represent numbers that are very small (i.e. close to zero).</li>
</ul>

<p>Such a format satisfies all the requirements:</p>

<ul>
  <li>It can represent numbers at wildly different magnitudes (limited by the length of the exponent)</li>
  <li>It provides the same relative accuracy at all magnitudes (limited by the length of the significand)</li>
  <li>It allows calculations across magnitudes: multiplying a very large and a very small number preserves the accuracy of both in the result.</li>
</ul>

<p>Decimal floating-point numbers usually take the form of a scientific notation with an explicit point always between the 1st and 2nd digits.</p>

<p>Implementing it another way:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">tolerance</span> <span class="mf">0.01</span><span class="p">)</span> <span class="c1">;; when changed ratio is less than 1%</span>
    <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">average</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">old-guess</span> <span class="nv">new-guess</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">abs</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">old-guess</span> <span class="nv">new-guess</span><span class="p">))</span> <span class="c1">;; if the changed ration is smaller than tolerance</span>
            <span class="nv">old-guess</span><span class="p">)</span>
         <span class="nv">tolerance</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span><span class="p">)</span> <span class="c1">;; improve the guess</span>
      <span class="p">(</span><span class="nf">average</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">guess</span><span class="p">)</span> <span class="nv">guess</span><span class="p">))</span>
    <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="nv">guess</span><span class="p">)</span> <span class="c1">;; iteration</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span><span class="p">))</span> <span class="c1">;; if further improving only changes a small ratio</span>
          <span class="nv">guess</span>
          <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="p">(</span><span class="nb">sqrt</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="18">1.8<a id="sec-1-8"></a></h2>

<p>Replace the approximation of the square root procedure with: [ \frac{x/y^2 + 2y}{3} ]</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">cubert</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">tolerance</span> <span class="mf">0.0001</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">good-enough?</span>
      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">guess</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">abs</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">guess</span> <span class="nv">guess</span> <span class="nv">guess</span><span class="p">)</span>
                   <span class="nv">x</span><span class="p">))</span>
           <span class="nv">tolerance</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">improve</span>
      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">y</span> <span class="nv">y</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">y</span><span class="p">))</span>
           <span class="mi">3</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">define</span> <span class="nv">cbrt-iter</span>
      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">guess</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span><span class="p">)</span>
            <span class="nv">guess</span>
            <span class="p">(</span><span class="nf">cbrt-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">cbrt-iter</span> <span class="mf">1.0</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cubert</span> <span class="mi">23</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="19">1.9<a id="sec-1-9"></a></h2>

<p>Considering the following two procedure of adding numbers:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; first procedure, recursive process</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">b</span>
      <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">dec</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>

<span class="c1">;; second procedure, iterative process</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">b</span>
      <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">dec</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="nv">b</span><span class="p">))))</span>
</code></pre></div></div>

<p>illustrate the process generated by each procedure in evaluating <code class="language-plaintext highlighter-rouge">(+ 4 5)</code></p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; first one</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">5</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">0</span> <span class="mi">5</span><span class="p">)))))</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">5</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">6</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="nf">inc</span> <span class="mi">8</span><span class="p">)</span>
<span class="mi">9</span>

<span class="c1">;; second one</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">dec</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">dec</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">dec</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">7</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">dec</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">0</span> <span class="mi">9</span><span class="p">)</span>
<span class="mi">9</span>
</code></pre></div></div>

<p>As we can see, the first procedure creates a recursive shape. While the second one creates a iterative shape.</p>

<h2 id="110">1.10<a id="sec-1-10"></a></h2>

<p>The following procedure computes a mathematical function called Armaniâs function:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">A</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">y</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">=</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">y</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">=</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">A</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">A</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))))))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>What are the values of the following expressions?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">9</span><span class="p">))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">8</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">7</span><span class="p">))))</span>
<span class="c1">;; ... 2 * 2 * 2 * ...</span>
<span class="c1">;; 2^10</span>

<span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="mi">16</span><span class="p">)</span>
<span class="c1">;; 2^16 = 2^{2^{4}}</span>

<span class="p">(</span><span class="nf">A</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;; 2^{2^{2^3}}</span>
</code></pre></div></div>

<p>Consider the following procedures, where A is the procedure defined above:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">))</span> <span class="c1">;; 2n</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">))</span> <span class="c1">;; 2^n</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">h</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="nv">n</span><span class="p">))</span> <span class="c1">;; 2^{2^n}</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">k</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">5</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">))</span>
</code></pre></div></div>

<p>Give concise mathematical definitions for the functions computed by the procedures <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">g</code>, and <code class="language-plaintext highlighter-rouge">h</code> for positive integer values of \(n\). For example, <code class="language-plaintext highlighter-rouge">(k, n)</code> computes \(5n^2\).</p>

<h2 id="111">1.11<a id="sec-1-11"></a></h2>

<p>A function \(f\) is defined as follows:</p>

\[f(n) = 

\begin{cases} 
n &amp;\text{if } n &lt; 3\\ 
f(n-1) + 2f(n-2) + 3f(n-3) &amp;\text{if } n \geq 3 
\end{cases}\]

<p>Write a procedure that computes \(f\) by means of an iterative process.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">f-iter</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">3</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f-iter</span> <span class="mi">1</span><span class="nv">st</span> <span class="mi">2</span><span class="nv">ec</span> <span class="mi">3</span><span class="nv">rd</span> <span class="nv">count</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">count</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">3</span><span class="nv">rd</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">f-iter</span> <span class="mi">2</span><span class="nv">ec</span>
                        <span class="mi">3</span><span class="nv">rd</span>
                        <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="mi">1</span><span class="nv">st</span><span class="p">)</span>
                           <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="mi">2</span><span class="nv">ec</span><span class="p">)</span>
                           <span class="mi">3</span><span class="nv">rd</span><span class="p">)</span>
                        <span class="p">(</span><span class="nb">-</span> <span class="nv">count</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">f</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">;; 1 2 3 10 (10+6+6)=22 </span>
</code></pre></div></div>

<h2 id="112">1.12<a id="sec-1-12"></a></h2>

<p>The following pattern of numbers is Pascalâs triangle.</p>

\[\begin{array}{ccccccccccc}
  &amp;   &amp;   &amp;   &amp;   &amp; 1 &amp;   &amp;   &amp;   &amp;   &amp;   \cr
  &amp;   &amp;   &amp;   &amp; 1 &amp;   &amp; 1 &amp;   &amp;   &amp;   &amp;   \cr
  &amp;   &amp;   &amp; 1 &amp;   &amp; 2 &amp;   &amp; 1 &amp;   &amp;   &amp;   \cr
  &amp;   &amp; 1 &amp;   &amp; 3 &amp;   &amp; 3 &amp;   &amp; 1 &amp;   &amp;   \cr
  &amp; 1 &amp;   &amp; 4 &amp;   &amp; 6 &amp;   &amp; 4 &amp;   &amp; 1 &amp;   \cr
1 &amp;   &amp; 5 &amp;   &amp; 10&amp;   &amp; 10&amp;   &amp; 5 &amp;   &amp; 1 \cr
\end{array}\]

<p>Write a procedure that computes elements of Pascalâs triangle by means of a recursive process.</p>

<p>The goal is to write a recursive procedure <code class="language-plaintext highlighter-rouge">(pas-tri r c)</code> that gives the number located at the \(r\) row and \(c\) column in the Pascalâs triangle.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">;; notice that there are special cases</span>
  <span class="c1">;; 1. at the edge</span>
  <span class="c1">;; 2. at the top</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pas-tri</span> <span class="nv">r</span> <span class="nv">c</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="k">or</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">r</span> <span class="nv">c</span><span class="p">)</span>
               <span class="p">(</span><span class="nb">=</span> <span class="nv">c</span> <span class="mi">0</span><span class="p">))</span>
           <span class="mi">1</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">pas-tri</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">r</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; the line above</span>
                            <span class="p">(</span><span class="nb">-</span> <span class="nv">c</span> <span class="mi">1</span><span class="p">))</span><span class="c1">;; the column to the left</span>
                   <span class="p">(</span><span class="nf">pas-tri</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">r</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;; the line above</span>
                            <span class="nv">c</span><span class="p">)))))</span>  <span class="c1">;; the same column</span>
<span class="p">(</span><span class="nf">pas-tri</span> <span class="mi">6</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="113">1.13<a id="sec-1-13"></a></h2>

<p>Prove that \(Fib(n)\) is the closest integer to \(\phi^n / \sqrt{5}\), where \(\phi = (1+\sqrt{5}) / 2\) Hint: Let \(\psi = (1 - \sqrt{5}) / 2\). Use induction and the definition of the Fibonacci numbers to prove that \(Fib(n) = (\phi^n - \psi^n) / \sqrt{5}\)</p>

<ol>
  <li>Prove that \(Fib(n) = (\phi^n - \psi^n) / \sqrt{5}\) by verifying for \(n = 0, 1\), and use the \(Fib(n) = Fib(n-1) + Fib(n-2)\) equation to further prove it. Notice that \(\phi^2 = \frac{3 + \sqrt{5}}{2}\) and \(\psi^2 = \frac{3 - \sqrt{5}}{2}\).</li>
  <li>How to prove that \(Fib(n)\) is the <strong>closest</strong> integer then? First it is an integer. And the difference between \(Fib(n)\) and \(\frac{\phi^n}{\sqrt{5}}\) is \(\psi^n / \sqrt{5}\)</li>
</ol>

<p>[ \frac{\psi^n}{\sqrt{5}} = \frac{(1-\sqrt{5})^n}{2^n\cdot\sqrt{5}} ]</p>

<p>Next step is to prove the equation is actually smaller than \(1/2\). This can be proven by two observations:</p>

<ol>
  <li>\(\psi\) itself is smaller than \(1/2\). So \(\psi^n\) must be much smaller than \(1/2\).</li>
  <li>\(\sqrt{5}\) is bigger than 2</li>
</ol>

<p>So dividing something that is clearly smaller than 1/2 by something that is bigger than 2 is going to produce a number that is less than 0.5.</p>

<p>That means the target \(\phi^n / \sqrt{5}\) is apart from the integer \(Fib(n)\) less than 0.5, making \(Fib(n)\) is the closest integer.</p>

<h2 id="114">1.14<a id="sec-1-14"></a></h2>

<p>Draw the tree illustrating the process generated by the <code class="language-plaintext highlighter-rouge">count-change</code> procedure of section 1.2.2 in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">count-change</span> <span class="mi">11</span><span class="p">)</span>
<span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">4</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">cc</span> <span class="mi">-39</span> <span class="mi">5</span><span class="p">))</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">3</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cc</span> <span class="mi">-14</span> <span class="mi">4</span><span class="p">))</span>     <span class="c1">;; 0</span>
   <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">3</span><span class="p">)</span>
      <span class="mi">0</span><span class="p">)</span>
   <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">2</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">cc</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">;; used a dime(10)</span>
      <span class="mi">0</span><span class="p">)</span>
   <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1">;; change 11 cents merely with 1 cent coins</span>
            <span class="p">(</span><span class="nf">cc</span> <span class="mi">6</span> <span class="mi">2</span><span class="p">))</span>     <span class="c1">;; used a nickle, 6 cents to go with last two types</span>
         <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">;; doing the rest 1 cent with two types of coins</span>
            <span class="p">(</span><span class="nf">cc</span> <span class="mi">-9</span> <span class="mi">3</span><span class="p">)))</span>   <span class="c1">;; 0</span>
      <span class="mi">0</span><span class="p">)</span>
   <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">0</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">cc</span> <span class="mi">10</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; used one cent</span>
            <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">6</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">;; used a nickle, try no more nickles solution</span>
               <span class="p">(</span><span class="nf">cc</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">;; used another nickle, 1 cent left to change</span>
         <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">;; doing the rest 1 cent with only one type of coins</span>
               <span class="p">(</span><span class="nf">cc</span> <span class="mi">-4</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; 0</span>
            <span class="mi">0</span><span class="p">))</span>
      <span class="mi">0</span><span class="p">)</span>
   <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">11</span> <span class="mi">0</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">cc</span> <span class="mi">10</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; used one cent</span>
            <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">6</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">;; used a nickle, try no more nickles solution</span>
               <span class="p">(</span><span class="nf">cc</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">;; used another nickle, 1 cent left to change</span>
         <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span>          <span class="c1">;; only one way to do 1 cent with 1 cent coins</span>
               <span class="mi">0</span><span class="p">)</span>         <span class="c1">;; 0</span>
            <span class="mi">0</span><span class="p">))</span>
      <span class="mi">0</span><span class="p">)</span>
   <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">0</span>
               <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">10</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">;; 0</span>
                  <span class="p">(</span><span class="nf">cc</span> <span class="mi">9</span> <span class="mi">1</span><span class="p">)))</span> <span class="c1">;; used the second cent</span>
            <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">6</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">;; 0</span>
                  <span class="p">(</span><span class="nf">cc</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1">;; used a nickle, one cent, try more cents</span>
               <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">;; one cent with one cent coins =&gt; 1</span>
                  <span class="p">(</span><span class="nf">cc</span> <span class="mi">-4</span> <span class="mi">2</span><span class="p">))))</span> <span class="c1">;; used two nickles, trying third, fail</span>
         <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span>
            <span class="mi">0</span><span class="p">))</span>
      <span class="mi">0</span><span class="p">)</span>
   <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>This procedure creates a tree-recursive structure, and the branching factor is 2. The deepest branch goes \(O(n)\) steps down, where \(n\) is the money to change. So the process takes \(O(2^n)\) steps to finish and \(O(n)\) space to run.</p>

<h2 id="115">1.15<a id="sec-1-15"></a></h2>

<p>The sine of an angle (specified in radians) can be computed by making use of the approximation \(\sin{x}\approx x\) if \(x\) is sufficiently small, and the trigonometric identity:</p>

<p>[ \sin{x} = 3 \sin{\frac{x}{3}} - 4\sin^3{\frac{x}{3}} ]</p>

<p>to reduce the size of the argument of \(sin\). (For purposes of this exercise an angle is considered âsufficiently smallâ if its magnitude is not greater than 0.1 radians.) These ideas are incorporated in the following procedures:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">cube</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">p</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="p">(</span><span class="nf">cube</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sine</span> <span class="nv">angle</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">abs</span> <span class="nv">angle</span><span class="p">)</span> <span class="mf">0.1</span><span class="p">))</span>
      <span class="nv">angle</span>
      <span class="p">(</span><span class="nf">p</span> <span class="p">(</span><span class="nf">sine</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">angle</span> <span class="mf">3.0</span><span class="p">)))))</span>
</code></pre></div></div>

<ol>
  <li>
    <p>How many times is the procedure <code class="language-plaintext highlighter-rouge">p</code> applied when <code class="language-plaintext highlighter-rouge">(sine 12.15)</code> is evaluated? \(12.5 / 3^x \leq 0.1\) By solving the equation above, we get \(x\geq5\), thus <code class="language-plaintext highlighter-rouge">p</code> is applied 5 times.</p>
  </li>
  <li>
    <p>What is the order of growth in space and number of steps (as a function of \(a\)) used by the process generated by the \(sine\) procedure when <code class="language-plaintext highlighter-rouge">(sine a)</code> is evaluated? The order of growth in number of steps is \(O(\log_3a)\). The order of growth in space is \(O(1)\).</p>
  </li>
</ol>

<h2 id="116">1.16<a id="sec-1-16"></a></h2>

<p>Design a procedure that evolves an <strong>iterative</strong> exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does <code class="language-plaintext highlighter-rouge">fast-expt</code>. Hint: use the observation that \((b^{n/2})^2 = (b^2)^{n/2}\), keep, along with the exponent \(n\) and the base \(b\), an additional state variable \(a\), and define the state transformation in such a way that the product \(ab^n\) is unchanged from state to state. At the beginning of the process \(a\) is taken to be 1, and the answer is given by the value of \(a\) at the end of the process. In general, the technique of defining an <strong>invariant quantity</strong> that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.</p>

<p>IDEA: Iteratively, take the exponent inside and replace old base with new ones, until outer exponent is 1. When the outer exponent left is even, further the process by making \(a\Leftarrow a^2\) and thus shrink the exponent by dividing it by 2. When the outer exponent is odd, take 1 away and make \(a\Leftarrow ab\), shrink the exponent by 1.</p>

<p>The above idea is terribly wrong! Because the case for dealing with odd exponent is problematic. The â1â taken out is not on the base of \(b\), but rather on the base of what is inside right now. Can we put another variable that hold whatâs outside?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">expt</span> <span class="nv">b</span> <span class="nv">n</span><span class="p">)</span> <span class="c1">;; expect b and n both to be integers.</span>
    <span class="p">(</span><span class="nf">expt-iter</span> <span class="nv">b</span> <span class="nv">n</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">))</span>

  <span class="c1">;; outer is for keep track of what is outside.</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">expt-iter</span> <span class="nv">b</span> <span class="nv">cnt</span> <span class="nv">a</span> <span class="nv">outer</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">cnt</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">=</span> <span class="nv">cnt</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">outer</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">even?</span> <span class="nv">cnt</span><span class="p">)</span> <span class="p">(</span><span class="nf">expt-iter</span> <span class="nv">b</span>
                                  <span class="p">(</span><span class="nb">/</span> <span class="nv">cnt</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">;; divide the outside expo by 2</span>
                                  <span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">)</span> <span class="c1">;; double the inside</span>
                                  <span class="nv">outer</span><span class="p">))</span>    <span class="c1">;; outside additional remains the same</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">expt-iter</span> <span class="nv">b</span>
                           <span class="p">(</span><span class="nb">-</span> <span class="nv">cnt</span> <span class="mi">1</span><span class="p">)</span>         <span class="c1">;; minus 1 to make it even</span>
                           <span class="nv">a</span>                 <span class="c1">;; inside remains the same</span>
                           <span class="p">(</span><span class="nb">*</span> <span class="nv">outer</span> <span class="nv">a</span><span class="p">)))))</span>   <span class="c1">;; outer additional get multiplied by the base</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">19</span><span class="p">)</span>
</code></pre></div></div>

<p>This solution I have here does not follow the hint given in the book. I havenât figured out how to compute it with an <em>invariant quantity</em>.</p>

<h2 id="117">1.17<a id="sec-1-17"></a></h2>

<p>The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication procedure (in which it is assumed that our language can only add, not multiply) is analogous to the <code class="language-plaintext highlighter-rouge">expt</code> procedure:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div></div>

<p>This algorithm takes a number of steps that is linear in \(b\). Now suppose we include, together with addition, operations <code class="language-plaintext highlighter-rouge">double</code>, which doubles the integer, and <code class="language-plaintext highlighter-rouge">halve</code>, which divides an (even) integer by 2. Using these, design a multiplication procedure analogous to <code class="language-plaintext highlighter-rouge">fast-expt</code> that uses a logarithmic number of steps.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">halve</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
     <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fast-mul</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">even?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">fast-mul</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">a</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">halve</span> <span class="nv">b</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span>
                 <span class="p">(</span><span class="nf">fast-mul</span> <span class="nv">a</span>
                           <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">))))))</span>
</code></pre></div></div>

<h2 id="118">1.18<a id="sec-1-18"></a></h2>

<p>Using the results of exercises 1.16 and 1.17, devise a procedure that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">halve</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fast-mul</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">mul-iter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">mul-iter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">add</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">=</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="nv">add</span><span class="p">))</span>
          <span class="p">((</span><span class="nb">even?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">mul-iter</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">a</span><span class="p">)</span>
                               <span class="p">(</span><span class="nf">halve</span> <span class="nv">b</span><span class="p">)</span> <span class="c1">;; logarithmic</span>
                               <span class="nv">add</span><span class="p">))</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">mul-iter</span> <span class="nv">a</span>
                          <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">)</span>
                          <span class="p">(</span><span class="nb">+</span> <span class="nv">add</span> <span class="nv">a</span><span class="p">)))))</span>  <span class="c1">;; carry the information along, makes it an iterative process</span>
<span class="p">(</span><span class="nf">fast-mul</span> <span class="mi">23</span> <span class="mi">59</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="119">1.19<a id="sec-1-19"></a></h2>

<p>There is a clever algorithm for computing the Fibonacci numbers in logarithmic numbers of steps. Recall the transformation of the state variables \(a\) and \(b\) in the <code class="language-plaintext highlighter-rouge">fib-iter</code> process of section 1.2.2:</p>

\[\begin{align*}
a &amp;\leftarrow a + b\\
b &amp;\leftarrow a
\end{align*}\]

<p>Call this transformation \(T\), and observe that applying \(T\) over and over again \(n\) times, starting with 1 and 0, produces the pair \(Fib(n+1)\) and \(Fib(n)\). In other words, the Fibonacci numbers are produced by \(T^n\), the $n$th power or the transformation \(T\), starting with the pair \((1,0)\).</p>

<p>Now consider the \(T\) to be the special case of \(p = 0\) and \(q = 1\) in a family of transformations \(T_{pq}\), where \(T_{pq}\) transforms the pair \((a,b)\) according to:</p>

\[\begin{align*}
a &amp;\leftarrow bq + aq + ap \\
b &amp;\leftarrow bp + aq
\end{align*}\]

<p>Show that if we apply such transformation \(T_{pq}\) twice, the effect is the same as using a single transformation \(T_{p^\prime q^\prime}\) of the same form, and compute \(p^\prime\) and \(q^\prime\) in terms of \(p\) and \(q\).</p>

<p>This gives us an explicit way to square these transformations, and thus we can compute \(T^n\) using successive squaring, as in the <code class="language-plaintext highlighter-rouge">fast-expt</code> procedure. Put this all together to complete the following procedure, which runs in a logarithmic number of steps:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">fib-iter</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fib-iter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">count</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">count</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span>
          <span class="p">((</span><span class="nb">even?</span> <span class="nv">count</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">fib-iter</span> <span class="nv">a</span>
                     <span class="nv">b</span>
                     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">q</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">p</span> <span class="nv">q</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">/</span> <span class="nv">count</span> <span class="mi">2</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">fib-iter</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">p</span><span class="p">))</span>
                          <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">q</span><span class="p">))</span>
                          <span class="nv">p</span>
                          <span class="nv">q</span>
                          <span class="p">(</span><span class="nb">-</span> <span class="nv">count</span> <span class="mi">1</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nf">fib</span> <span class="mi">13</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="120">1.20<a id="sec-1-20"></a></h2>

<p>The process that a procedure generates is of course independent on the rules used by the interpreter. As an example, consider the iterative <code class="language-plaintext highlighter-rouge">gcd</code> procedure given in text book. Suppose we were to interpret this procedure using normal-order evaluation, as discussed in section 1.1.5. (The normal-order-evaluation rule for <code class="language-plaintext highlighter-rouge">if</code> is described in exercise 1.5.) Using the substitution method (for normal order), illustrate the process generated in evaluating <code class="language-plaintext highlighter-rouge">(gcd 206 40)</code> and indicate the <code class="language-plaintext highlighter-rouge">remainder</code> operations that are actually performed. How many <code class="language-plaintext highlighter-rouge">remainder</code> operations are actually performed in the normal-order evaluation of <code class="language-plaintext highlighter-rouge">(gcd 206 40)</code>? In the applicative-order evaluation?</p>

<p>Review that applicative-order will evaluate the operands whenever possible, and then apply the operator to the operands. However, normal order will delay any evaluation to a point where something has to be evaluated to proceed. In this exercise, the normal order will only evaluate expressions either when: 1) fully expanded, 2) <code class="language-plaintext highlighter-rouge">if</code> special formâs predicate needs to be evaluated to decide which clause (the consequent or the alternative) to expand next.</p>

<p>For applicative-order, <code class="language-plaintext highlighter-rouge">remainder</code> gets evaluated 4 times as it shows here:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">gcd</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
<span class="c1">;;   |</span>
<span class="c1">;;   v</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">40</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span> <span class="c1">;; 1 (remainder eval counter)</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">40</span> <span class="mi">6</span><span class="p">)</span>
<span class="c1">;;   |</span>
<span class="c1">;;   v</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">6</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span> <span class="mi">6</span><span class="p">))</span>    <span class="c1">;; 2</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">6</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">;;   |</span>
<span class="c1">;;   v</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">6</span> <span class="mi">4</span><span class="p">))</span>     <span class="c1">;; 3</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">;;   |</span>
<span class="c1">;;   v</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">))</span>     <span class="c1">;; 4</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">2</span> <span class="mi">0</span><span class="p">)</span>                   <span class="c1">;; predicate is true, stop and return 2</span>
</code></pre></div></div>

<p>For normal-order evaluation:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">gcd</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">40</span> <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="mi">40</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span>

<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>                               <span class="c1">;; 1</span>
<span class="c1">;; 6, not 0</span>
<span class="p">(</span><span class="nb">gcd</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)))</span>

<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>                                            <span class="c1">;; 1 +2</span>
                  <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span>
       <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="c1">;;40%6 = 4, not 0</span>

<span class="p">(</span><span class="nb">gcd</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span>               <span class="c1">;; a</span>
     <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                           <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))))</span>  <span class="c1">;; b</span>

<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>                             <span class="c1">;; 1 +2 +4</span>
                  <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                             <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)))</span> <span class="c1">;; b == 0?</span>
       <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>
<span class="c1">;; 2, not zero</span>

<span class="p">(</span><span class="nb">gcd</span> <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                           <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)))</span>   <span class="c1">;; a</span>
     <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                           <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
                           <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                                      <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)))))</span> <span class="c1">;; b</span>
<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>                                   <span class="c1">;; 1 +2 +4 +7 = 14</span>
                             <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))</span>
                  <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                                        <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">))))</span> <span class="c1">;; 4%2 = 0</span>
       <span class="mi">0</span><span class="p">)</span> <span class="o">...</span><span class="p">)</span>

<span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">remainder</span> <span class="mi">40</span>
                      <span class="p">(</span><span class="nb">remainder</span> <span class="mi">206</span> <span class="mi">40</span><span class="p">)))</span> <span class="c1">;; fully expanded, evaluate all rest expressions</span>
<span class="c1">;; finally, 14 + 4 = 18</span>
<span class="c1">;; So the remainder get evaluated 18 times in total.</span>
<span class="c1">;; FORMULA?</span>
</code></pre></div></div>

<p>Notice that, the changing of numbers of <code class="language-plaintext highlighter-rouge">remainder</code> appearing in the two operands of <code class="language-plaintext highlighter-rouge">gcd</code> obeys the following pattern:</p>

\[\begin{align*}
(R_a,R_b) &amp;\rightarrow \text{Occurance of remainder procedure}\\
(0, 0)     &amp;\rightarrow  \text{None}   \\
(0, 1)     &amp;\rightarrow 1+(0+0)=1          \\
(1, 2)     &amp;\rightarrow 1+(0+1)=2          \\
(2, 4)     &amp;\rightarrow 1+(1+2)=4          \\
(4, 7)     &amp;\rightarrow 1+(2+4)=7          \\
4          &amp;\rightarrow \text{predicate true, evaluate }a
\end{align*}\]

<p>Assume our iteration starts from 0. For simplicity, we consider when applying <code class="language-plaintext highlighter-rouge">gcd</code>, the two operands \(a\) and \(b\) are generated by last iteration in the alternate clause. The 1 that appears in each line is the new <code class="language-plaintext highlighter-rouge">remainder</code> that kicks in in the alternative clause. And the addition between the parentheses means using the operand \(a\) and \(b\) from previous iteration are used as new operands for the new <code class="language-plaintext highlighter-rouge">remainder</code> procedure.</p>

<p>First off, we mainly evaluate <code class="language-plaintext highlighter-rouge">remainder</code> when in the <code class="language-plaintext highlighter-rouge">if</code> predicate. Each time, when we forward one iteration, the number of <code class="language-plaintext highlighter-rouge">remainder</code> in \(b\) from last iteration is evaluated, to determine which clause to expand next. That is: \(0+1+2+4+7\) in this example. Generally, the predicate evaluation will not stop until in the final iteration, where \(b\) equals to 0. When that happens, all the things in \(a\) got evaluated.</p>

<p>To formulate it, lets assume \((R_a^{\langle i \rangle}, R_b^{\langle i \rangle})\) is a pair of integers that record how many times <code class="language-plaintext highlighter-rouge">remainder</code> is invoked in \(a\) and \(b\) during \(i\) th iteration, starting from 0. Say \(k\) is the final iteration where \(b^{\langle k-1 \rangle}=0\). Then the total times that <code class="language-plaintext highlighter-rouge">remainder</code> gets evaluated is:</p>

<p>[ T(remainder) = R_b^{\langle 0 \rangle} + R_b^{\langle 1 \rangle} + R_b^{\langle 2 \rangle} + \cdots + R_b^{\langle k-1 \rangle} + R_a^{\langle k-1 \rangle} ]</p>

<p>Notice that, [ R_b^{\langle i \rangle} = R_a^{\langle i+1 \rangle} = \sum_{j = 0}^i Fib(j) ]</p>

<p>Thus the formula can be rewritten into:</p>

<p>[ T(remainder) = \sum_{j = 0}^0 Fib(j) + \sum_{j = 0}^1 Fib(j) + \sum_{j = 0}^2 Fib(j) + \cdots + 2\sum_{j = 0}^{k-2} Fib(j) + \sum_{j = 0}^{k-1} Fib(j) ]</p>

<h2 id="121">1.21<a id="sec-1-21"></a></h2>

<p>Use the <code class="language-plaintext highlighter-rouge">smallest-divisor</code> procedure to find the smallest divisor of each of the following numbers: 199, 1999, 199999.</p>

<p>Recall that the procedure ~~ is:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">smallest-divisor</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">;; find the first divisor starting from 2</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>   <span class="c1">;; end test</span>
        <span class="p">((</span><span class="nf">divides?</span> <span class="nv">test-divisor</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">test-divisor</span><span class="p">)</span>   <span class="c1">;; modulo test</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">test-divisor</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">divides?</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="s">"b%a == 0?"</span>
  <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)</span>
     <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div>

<p>Running this procedure yields:</p>

<table>
  <thead>
    <tr>
      <th>Number</th>
      <th>smallest-divisor</th>
      <th>primality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>199</td>
      <td>199</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>1999</td>
      <td>1999</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>19999</td>
      <td>7</td>
      <td>N</td>
    </tr>
  </tbody>
</table>

<h2 id="122">1.22<a id="sec-1-22"></a></h2>

<p>Most Lisp implementations include a primitive called <code class="language-plaintext highlighter-rouge">runtime</code> that returns an integer that specifies the amount of time the system has been running (measured, for example, in microseconds). The following <code class="language-plaintext highlighter-rouge">timed-prime-test</code> procedure, when called with an integer \(n\), prints \(n\) and checks to see if \(n\) is prime. If it is, the procedure prints three asterisks followed by the amount of time used in performing the test.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">timed-prime-test</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">start-prime-test</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">runtime</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">start-prime-test</span> <span class="nv">n</span> <span class="nv">start-time</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">prime?</span> <span class="nv">n</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">report-prime</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nf">runtime</span><span class="p">)</span> <span class="nv">start-time</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">report-prime</span> <span class="nv">elapsed-time</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">" *** "</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="nv">elapsed-time</span><span class="p">))</span>
</code></pre></div></div>

<p>Using this procedure, write a procedure <code class="language-plaintext highlighter-rouge">search-for-primes</code> that checks the primality of consecutive odd integers in a specified range. Use your procedure to find the 3 smallest primes:</p>

<ul>
  <li>larger than 1000;</li>
  <li>larger than 10,000;</li>
  <li>larger than 100,000;</li>
  <li>larger than 1,000,000.</li>
</ul>

<p>Note the time needed to test each prime. Since the testing algorithm has order of growth \(\Theta(\sqrt{n})\), you should expect that testing or primes around 10,000 should take about \(\sqrt{10}\) times as long as testing for primes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the \(\sqrt{n}\) prediction? Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">search-for-primes</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">"checks the primality of consecutive odd integers in a specified range."</span>
  <span class="p">(</span><span class="nf">search-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">start</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">search-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">curr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">curr</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nb">display</span> <span class="s">"--END--"</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">even?</span> <span class="nv">curr</span><span class="p">)</span> <span class="p">(</span><span class="nf">search-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">curr</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">timed-prime-test</span> <span class="nv">curr</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">search-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">curr</span> <span class="mi">2</span><span class="p">)))))</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>Smallest 3 Larger than</th>
      <th>Prime Numbers</th>
      <th>Elapsed Time</th>
      <th>Â </th>
      <th>Â </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&gt;1,000</td>
      <td>1009</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1013</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1019</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;10,000</td>
      <td>10007</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10009</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10037</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;100,000</td>
      <td>100003</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>100019</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>100043</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;1,000,000</td>
      <td>1000003</td>
      <td>1e-4</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000033</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000037</td>
      <td>0.</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;1,000,000,000</td>
      <td>1000000007</td>
      <td>2e-2</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000000009</td>
      <td>2e-2</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000000021</td>
      <td>1e-2</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;10,000,000,000</td>
      <td>10000000019</td>
      <td>0.05</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10000000033</td>
      <td>0.07</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10000000061</td>
      <td>0.05</td>
      <td>Â </td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<p>My data for required tests doesnât bear out any signs of \(\Theta(\sqrt{n})\) order of growth. Maybe I should try larger numbers.</p>

<p>After trying numbers larger than 1 billion and numbers larger than 10 billion, the relationship between them starts to reveal itself. Notice that the average running time ratio is:</p>

<p>[ \frac{(0.05 + 0.07 + 0.05) / 3}{(0.02 + 0.02 + 0.01) / 3} = \frac{17}{5} = 3.4 \approx \sqrt{10} ]</p>

<h2 id="123">1.23<a id="sec-1-23"></a></h2>

<p>The <code class="language-plaintext highlighter-rouge">smalles-divisor</code> procedure shown at the start of this section does lots of needles testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if it is divisible by any larger even numbers. This suggests that the values used for <code class="language-plaintext highlighter-rouge">test-divisor</code> should not be 2,3,4,5,6â¦, but rather 2,3,5,7,9â¦ (Not quite here, notice 9 is also a repeated useless check because we would have get the result from testing 3. Actually we should only try prime numbers here. But seems like the exercise is not aimed at that, so we will not consider this fact yet.) To implement this change, define a procedure <code class="language-plaintext highlighter-rouge">next</code> that returns 3 if its input is 2 and otherwise returns its input plus 2. Modify the <code class="language-plaintext highlighter-rouge">smallest-divisor</code> procedure to use <code class="language-plaintext highlighter-rouge">(next test-divisor)</code> instead of <code class="language-plaintext highlighter-rouge">(+ test-divisor 1)</code>. With <code class="language-plaintext highlighter-rouge">timed-prime-test</code> incorporating this modified version of <code class="language-plaintext highlighter-rouge">smallest-divisor</code>, run the test for each of the 12 primes found in exercise 1.22. Since this modification halves the number of test steps, you should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">curr</span><span class="p">)</span>
  <span class="s">"return the next number as new test-divisor."</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">curr</span> <span class="mi">2</span><span class="p">)</span>
      <span class="mi">3</span>
      <span class="p">(</span><span class="nb">+</span> <span class="nv">curr</span> <span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">smallest-divisor</span> <span class="nv">n</span><span class="p">)</span>
  <span class="s">"Find the smallest divisor of n that is bigger than 1."</span>
  <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">)</span>
  <span class="s">"Find divisor of n, starting from test-divisor."</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">divides?</span> <span class="nv">test-divisor</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">test-divisor</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span>
                            <span class="p">(</span><span class="nf">next</span> <span class="nv">test-divisor</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">divides?</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="s">"Can b be divided by a with remainder 0."</span>
  <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)</span>
     <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div>

<p>Because the normal 12 tests required in the textbook doesnât yield big enough elapse time on my machine, I am going to do the billion tests instead here.</p>

<table>
  <thead>
    <tr>
      <th>Bigger Than</th>
      <th>Number</th>
      <th>Original</th>
      <th>Modified</th>
      <th>Â </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&gt;1,000,000,000</td>
      <td>1000000007</td>
      <td>2e-2</td>
      <td>0.02</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000000009</td>
      <td>2e-2</td>
      <td>0.02</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000000021</td>
      <td>1e-2</td>
      <td>0.01</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;10,000,000,000</td>
      <td>10000000019</td>
      <td>0.05</td>
      <td>0.05</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10000000033</td>
      <td>0.07</td>
      <td>0.04</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10000000061</td>
      <td>0.05</td>
      <td>0.04</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<p>Notice that for most numbers the result remained the same when it comes to time took. Why? Letâs count how many steps we actually do in each <code class="language-plaintext highlighter-rouge">find-divisor</code> iteration in both cases:</p>

<table>
  <thead>
    <tr>
      <th>Step</th>
      <th>Original</th>
      <th>Modified</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Comparison</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>divides?</td>
      <td>Y</td>
      <td>Y</td>
    </tr>
    <tr>
      <td>else</td>
      <td>(+ test-divisor 1)</td>
      <td>Equal to 2 test</td>
    </tr>
    <tr>
      <td>Â </td>
      <td>;; forward next iteration</td>
      <td>(most cases) (+ curr 2)</td>
    </tr>
  </tbody>
</table>

<p>As we can see here, although we have less iterations because we only test odd numbers now, but to generate the <code class="language-plaintext highlighter-rouge">next</code> sequence correctly, we embedded a lots of useless comparisons against 2 to handle the special starting case. Thus make the total steps needed are the same. (This answer may not be correct.)</p>

<h2 id="124">1.24<a id="sec-1-24"></a></h2>

<p>Modify the <code class="language-plaintext highlighter-rouge">timed-prime-test</code> procedure of exercise 1.22 to use <code class="language-plaintext highlighter-rouge">fast-prime?</code> (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat test has \(\Theta(\log n)\) growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000? Do your data bear this out? Can you explain any discrepancy you find?</p>

<p>Quick review of the code:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="nv">exp</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">exp</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">even?</span> <span class="nv">exp</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">exp</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
                    <span class="nv">m</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else</span>
         <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">base</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">exp</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
                    <span class="nv">m</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fermat-test</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">try-it</span> <span class="nv">a</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">try-it</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">n</span> <span class="nv">times</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">times</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>  <span class="c1">;; all tests passed, very likely a prime number</span>
        <span class="p">((</span><span class="nf">fermat-test</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">times</span> <span class="mi">1</span><span class="p">)))</span> <span class="c1">;; pass one test, continue</span>
        <span class="p">(</span><span class="k">else</span> <span class="nv">false</span><span class="p">)))</span> <span class="c1">;; failed one test, certainly not a prime number</span>
</code></pre></div></div>

<p>Then, embedded this into our <code class="language-plaintext highlighter-rouge">timed-prime-test</code>:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">timed-prime-test</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">start-prime-test</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">runtime</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">start-prime-test</span> <span class="nv">n</span> <span class="nv">start-time</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">n</span> <span class="mi">1000000</span><span class="p">)</span> <span class="c1">;; replaced the prime test used here!</span>
      <span class="p">(</span><span class="nf">report-prime</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nf">runtime</span><span class="p">)</span> <span class="nv">start-time</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">report-prime</span> <span class="nv">elapsed-time</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">" *** "</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="nv">elapsed-time</span><span class="p">))</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>Bigger Than</th>
      <th>Number</th>
      <th>Time(100)</th>
      <th>(1000000)</th>
      <th>Â </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&gt;1,000,000,000</td>
      <td>1000000007</td>
      <td>0.01</td>
      <td>26.23</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000000009</td>
      <td>0.00</td>
      <td>25.61</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>1000000021</td>
      <td>0.01</td>
      <td>26.14</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>&gt;10,000,000,000</td>
      <td>10000000019</td>
      <td>0.01</td>
      <td>30.73</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10000000033</td>
      <td>0.01</td>
      <td>30.05</td>
      <td>Â </td>
    </tr>
    <tr>
      <td>Â </td>
      <td>10000000061</td>
      <td>0.01</td>
      <td>31.90</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<p>Right now, the results seems identical, I suppose that is because the number of times we test for each number is too small, replacing 100 with 1000,000.</p>

<p>The ratio: [ \frac{30.73 + 30.05 + 31.90}{26.23 + 26.61 + 26.14} = 1.1769 \approx \frac{\log 10000000000}{\log 1000000000} = 1.1111 ]</p>

<h2 id="125">1.25<a id="sec-1-25"></a></h2>

<p>Alyssa P. Hacker complains that we went to a lot of extra work in writing <code class="language-plaintext highlighter-rouge">expmod</code>. After all, she says, since we already know how to compute exponentials, we could have simply written:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">expmod2</span> <span class="nv">base</span> <span class="nv">exp</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nf">fast-expt</span> <span class="nv">base</span> <span class="nv">exp</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
</code></pre></div></div>

<p>Is she correct? Would this procedure serve as well for our fast prime tester? Explain.</p>

<p>They both yield the same results. However, the version of <code class="language-plaintext highlighter-rouge">expmod</code> is constantly using modulo arithmetic to downsize the numbers related in computation. However, the version proposed by Alyssa, is actually computing the real result for the exponential, which can be slower when the numbers are large enough. It will still give the correct answer but slower.</p>

<h2 id="126">1.26<a id="sec-1-26"></a></h2>

<p>Louis Reasoner is having great difficulty doing exercise 1.24. His <code class="language-plaintext highlighter-rouge">fast-prime?</code> test seems to run more slowly than his <code class="language-plaintext highlighter-rouge">prime?</code> test. Louis calls his friend Eva Lu Ator over to help. When they examine Louisâs code, they find that he has rewritten the <code class="language-plaintext highlighter-rouge">expmod</code> procedure to use an explicit multiplication, rather than calling <code class="language-plaintext highlighter-rouge">square</code>:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="nv">exp</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">exp</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">even?</span> <span class="nv">exp</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">exp</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">m</span><span class="p">)</span>
                       <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">exp</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
                    <span class="nv">m</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else</span>
         <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">base</span>
                       <span class="p">(</span><span class="nf">expmod</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">exp</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
                    <span class="nv">m</span><span class="p">))))</span>
</code></pre></div></div>

<p>âI donât see what difference that could make,â says Louis. âI do.â says Eva. âBy writing the procedure like that, you have transformed the \(\Theta(\log n)\) process into a \(\Theta(n)\) process.â Explain.</p>

<p>The recursive call for the even cases are now have branching factor of 2 instead of 1. So instead of a linear recursion with the depth of \(O(\log n)\), now the explicit multiplication version becomes a tree recursion with the depth of \(O(\log n)\). Thus the growth becomes \(\Theta(n)\)</p>

<h2 id="127">1.27<a id="sec-1-27"></a></h2>

<p>Demonstrate that the Carmichael numbers listed in footnote 47 really do fool the Fermat test. That is, write a procedure that takes an integer \(n\) and tests whether \(a^n\) is congruent to \(a\) modulo \(n\) for every \(a&lt;n\), and try your procedure on the given Carmichael numbers.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">congruent-test</span> <span class="nv">n</span><span class="p">)</span>
  <span class="s">"test every number a&lt;n: if a^n is congruent to a modulo n"</span>
  <span class="p">(</span><span class="nf">congruent-iter</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">congruent-iter</span> <span class="nv">n</span> <span class="nv">counter</span><span class="p">)</span>
  <span class="s">"Counter starts from 1 and ends at n"</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">counter</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span> <span class="c1">;; end test</span>
        <span class="c1">;; test counter, if passed, continue</span>
        <span class="p">((</span><span class="nf">single-fermat-test</span> <span class="nv">n</span> <span class="nv">counter</span><span class="p">)</span> <span class="p">(</span><span class="nf">congruent-iter</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">counter</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">else</span> <span class="nv">false</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">single-fermat-test</span> <span class="nv">n</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nf">expmod</span> <span class="nv">a</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</code></pre></div></div>

<p>Running it with the 6 Carmichael numbers mentioned:</p>

<table>
  <thead>
    <tr>
      <th>Carmichael Number</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>561</td>
      <td>t</td>
    </tr>
    <tr>
      <td>1105</td>
      <td>t</td>
    </tr>
    <tr>
      <td>1729</td>
      <td>t</td>
    </tr>
    <tr>
      <td>2465</td>
      <td>t</td>
    </tr>
    <tr>
      <td>2821</td>
      <td>t</td>
    </tr>
    <tr>
      <td>6601</td>
      <td>t</td>
    </tr>
  </tbody>
</table>

<p>We can see that all these numbers can fool Fermat test.</p>

<p>(The following section is not required by the exercise. It is out of my own curiosity.) Next, I want to find the next Carmichael number not mentioned in the book using the above procedure:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-carmichael</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">"Find all carmichael numbers between start and end."</span>
  <span class="p">(</span><span class="nf">find-carmichael-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">start</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-carmichael-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">test</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">test</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nb">display</span> <span class="s">"==END=="</span><span class="p">))</span>
        <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">prime?</span> <span class="nv">test</span><span class="p">))</span> <span class="p">(</span><span class="nf">congruent-test</span> <span class="nv">test</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">display</span> <span class="nv">test</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">find-carmichael-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">test</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">find-carmichael-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">test</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div></div>

<p>It is a procedure that looks for Carmichael numbers within an range \([start, end)\).</p>

<p>By running the above procedure, I found the following Carmichael Numbers: 8911, 10585, 15841.</p>

<p>Comparing them with the Carmichael number list online confirms the correctness of the <code class="language-plaintext highlighter-rouge">find-carmichael</code> procedure.</p>

<h2 id="128">1.28<a id="sec-1-28"></a></h2>

<p>One variant of Fermat test that cannot be fooled is called the Miller-Rabin test. This starts from an alternate form of Fermatâs Little Theorem, which states that if \(n\) is prime number and \(a\) is any positive integer less than \(n\), then \(a^{n-1}\) is congruent to 1 modulo \(n\). To test the primality of a number \(n\) by the Miller-Rabin test, we pick a random number \(a&lt;n\) and raise \(a\) to the \((n-1)\) power modulo \(n\) using the <code class="language-plaintext highlighter-rouge">expmod</code> procedure. <strong>However, whenever we perform the squaring step in <code class="language-plaintext highlighter-rouge">expmod</code>, we check to see if we have discovered a ânontrivial square root of 1 modulo n,â that is, a number not equal to 1 or \(n-1\) whose square is equal to 1 modulo \(n\).</strong> It is possible to prove that if such a nontrivial square root of 1 exists, then \(n\) is not prime. It is also possible to prove that if \(n\) is an odd number that is not prime, then, for at least half the numbers \(a&lt;n\), computing \(a^{n-1}\) in this way will reveal a nontrivial square root of 1 modulo \(n\). (This is why the Miller-Rabin test cannot be fooled.) Modify the <code class="language-plaintext highlighter-rouge">expmod</code> procedure to signal if it discovers a nontrivial square root of 1, and use this to implement the Miller-Rabin test with a procedure analogous to <code class="language-plaintext highlighter-rouge">fermat-test</code>. Check your procedure by testing various known primes and non-primes. Hint: One convenient way to make <code class="language-plaintext highlighter-rouge">expmod</code> signal it to have it return 0.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">expmod-m1</span> <span class="nv">base</span> <span class="nv">exp</span> <span class="nv">m</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">exp</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">even?</span> <span class="nv">exp</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nf">test-nontrivial-m1</span> <span class="p">(</span><span class="nf">expmod-m1</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">exp</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
                    <span class="nv">m</span><span class="p">))</span>
        <span class="p">(</span><span class="k">else</span>
         <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">base</span> <span class="p">(</span><span class="nf">expmod-m1</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">exp</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
                    <span class="nv">m</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">test-nontrivial-m1</span> <span class="nv">a</span> <span class="nv">n</span><span class="p">)</span>
  <span class="s">"test if: a not equal to 1 or n-1 but a^2 equals to 1 modulo n"</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="k">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">;; if it is nontrivial case</span>
         <span class="mi">0</span><span class="p">)</span> <span class="c1">;; return zero</span>
        <span class="p">(</span><span class="k">else</span> <span class="nv">a</span><span class="p">)))</span> <span class="c1">;; else, return its original value</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">miller-rabin</span> <span class="nv">n</span><span class="p">)</span>
  <span class="s">"test if n is prime using miller rabin method"</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">try-it</span> <span class="nv">a</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nf">expmod-m1</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">try-it</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">n</span> <span class="nv">times</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">times</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">miller-rabin</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">fast-prime?</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">times</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">else</span> <span class="nv">false</span><span class="p">)))</span>
</code></pre></div></div>

<p>I tested this procedure with common numbers and large prime numbers. Next I am going to write a procedure that tests and gives all prime numbers within a range:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">print-primes</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">print-primes-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">start</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">print-primes-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="nv">curr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">curr</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nb">display</span> <span class="s">"---END---"</span><span class="p">))</span>
        <span class="p">((</span><span class="nf">fast-prime?</span> <span class="nv">curr</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">;; test 20 random numbers</span>
         <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">display</span> <span class="nv">curr</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">print-primes-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">curr</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">print-primes-iter</span> <span class="nv">start</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">curr</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div></div>

<p>By printing a lot of prime numbers and comparing them with <code class="language-plaintext highlighter-rouge">prime?</code> procedureâs outputs, we can verify that this procedure does what we intended.</p>

<h2 id="129">1.29<a id="sec-1-29"></a></h2>

<p>Simpsonâs Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpsonâs rule, the integral of a function \(f\) between \(a\) and \(b\) is approximated as [ \frac{h}{3}[y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \cdots + 2y_{n-2} + 4y_{n-1} + y_n] ] where \(h=(b-a)/n\), for some even integer \(n\), and \(y_k=f(a+kh)\). (Increasing \(n\) increases the accuracy of the approximation.) Define a procedure that takes as arguments \(f\), \(a\), \(b\), and \(n\) and returns the value of the integral, computed using Simpsonâs Rule. Use your procedure to integrate <code class="language-plaintext highlighter-rouge">cube</code> between 0 and 1 (with \(n=100\) and \(n=1000\), and compare the results to those of the <code class="language-plaintext highlighter-rouge">integral</code> procedure shown above.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">simpson-integral</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">h</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">n</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">coef</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">diff</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">h</span><span class="p">)))</span> <span class="c1">;; compute coefficients based on the x difference.</span>
      <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="k">or</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">diff</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">diff</span> <span class="nv">n</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">((</span><span class="nb">even?</span> <span class="nv">diff</span><span class="p">)</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="p">(</span><span class="k">else</span> <span class="mf">4.0</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">simpson-term</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">coef</span> <span class="nv">x</span><span class="p">)</span>
                              <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)))</span> <span class="c1">;; how to deal with the coefficients? 1, 4, 2, 4, 2, ..., 2, 4, 1</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">simpson-next</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">h</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">simpson-term</span> <span class="nv">a</span> <span class="nv">simpson-next</span> <span class="nv">b</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">/</span> <span class="nv">h</span> <span class="mf">3.0</span><span class="p">)))</span>
</code></pre></div></div>

<p>Running this procedure with different \(n\) yields:</p>

<table>
  <tbody>
    <tr>
      <td>\(n) value</td>
      <td>Result</td>
    </tr>
    <tr>
      <td>100</td>
      <td>.24999999999999992</td>
    </tr>
    <tr>
      <td>1000</td>
      <td>.2500000000000002</td>
    </tr>
  </tbody>
</table>

<p>We see that it is more accurate than the results in previous section.</p>

<h2 id="130">1.30<a id="sec-1-30"></a></h2>

<p>The <code class="language-plaintext highlighter-rouge">sum</code> procedure in the textbook generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">iter</span> <span class="nv">a</span> <span class="nv">result</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="nv">result</span>
        <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">+</span> <span class="nv">result</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">iter</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="131">1.31<a id="sec-1-31"></a></h2>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">sum</code> procedure is only the simplest of a vast number of similar abstractions that can be captured as</li>
</ol>

<p>higher-order functions. Write an analogous procedure called <code class="language-plaintext highlighter-rouge">product</code> that returns the product of the values of a function at points over a given range. Show how to define <code class="language-plaintext highlighter-rouge">factorial</code> in terms of <code class="language-plaintext highlighter-rouge">product</code>. Also, use <code class="language-plaintext highlighter-rouge">product</code> to compute approximations to \(\pi\) using the formula: [ \frac{\pi}{4} = \frac{2\cdot 4\cdot 4 \cdot 6 \cdot 6 \cdot 8 \cdots}{3\cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \cdots} ]</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">product</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
      <span class="mi">1</span>
      <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">product</span> <span class="nv">term</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pi-product</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pi-term</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mf">1.0</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pi-next</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">product</span> <span class="nv">pi-term</span> <span class="nv">start</span> <span class="nv">pi-next</span> <span class="nv">end</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pi-estimate</span> <span class="nv">accuracy</span><span class="p">)</span>
  <span class="s">"the larger the accuracy, the more accurate the estimation is."</span>
  <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span>
     <span class="p">(</span><span class="nf">pi-product</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">accuracy</span><span class="p">)))))</span>
</code></pre></div></div>

<p>Running this procedure yields:</p>

<table>
  <thead>
    <tr>
      <th>Accuracy</th>
      <th>Estimation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>20</td>
      <td>3.1774930</td>
    </tr>
    <tr>
      <td>200</td>
      <td>3.1454832</td>
    </tr>
    <tr>
      <td>2000</td>
      <td>3.1319849</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>If your <code class="language-plaintext highlighter-rouge">product</code> procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.</li>
</ol>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">product</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">product-iter</span> <span class="nv">a</span> <span class="nv">result</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="nv">result</span>
        <span class="p">(</span><span class="nf">product-iter</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span>
                      <span class="p">(</span><span class="nb">*</span> <span class="nv">result</span>
                         <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">product-iter</span> <span class="nv">a</span> <span class="mf">1.0</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="132">1.32<a id="sec-1-32"></a></h2>

<ol>
  <li>Show that <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">product</code> are both special cases of a still more general notion called <code class="language-plaintext highlighter-rouge">accumulate</code> that combines a collection of terms, using some general accumulation function: <code class="language-plaintext highlighter-rouge">(accumulate combiner null-value term a next b)</code> It takes as arguments the same term and range specifications as <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">product</code>, together with a <code class="language-plaintext highlighter-rouge">combiner</code> procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a <code class="language-plaintext highlighter-rouge">null-value</code> that specifies what base value to use when the terms run out. Write <code class="language-plaintext highlighter-rouge">accumulate</code> and show how sum and product can both be defined as simple calls to <code class="language-plaintext highlighter-rouge">accumulate</code>.</li>
  <li>Write another version of <code class="language-plaintext highlighter-rouge">accumulate</code>, that will generate an iterative or a recursive process.</li>
</ol>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; recursive process version</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
      <span class="nv">null-value</span>
      <span class="p">(</span><span class="nf">combiner</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">))))</span>

<span class="c1">;; iterative process version</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">combiner</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">accumulate-iter</span> <span class="nv">a</span> <span class="nv">result</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="nv">result</span>
        <span class="p">(</span><span class="nf">accumulate-iter</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">combiner</span> <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
                                   <span class="nv">result</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">accumulate-iter</span> <span class="nv">a</span> <span class="nv">null-value</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">+</span> <span class="mf">0.0</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">product</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">accumulate</span> <span class="nv">*</span> <span class="mf">1.0</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="133">1.33<a id="sec-1-33"></a></h2>

<p>You can obtain an even more general version of <code class="language-plaintext highlighter-rouge">accumulate</code> by introducing the notion of <code class="language-plaintext highlighter-rouge">filter</code> on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting <code class="language-plaintext highlighter-rouge">filtered-accumulate</code> abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write <code class="language-plaintext highlighter-rouge">filtered-accumulate</code> as a procedure. Show how to express the following using it:</p>

<ol>
  <li>the sum of the squares of the prime numbers in the interval \(a\) to \(b\) (assuming that you have <code class="language-plaintext highlighter-rouge">prime?</code>) predicate already written.</li>
  <li>the product of all the positive integers less than \(n\) that are relatively prime to \(n\) (i.e., all positive integers \(i&lt;n\) such that \(GCD(i,n) = 1\)).</li>
</ol>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; recursive process</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nv">combiner</span>     <span class="c1">;; 2 args, combine values</span>
                             <span class="nv">filter</span>       <span class="c1">;; 1 arg, on terms to be combined</span>
                             <span class="nv">null-value</span>
                             <span class="nv">term</span>
                             <span class="nv">a</span>
                             <span class="nv">next</span>
                             <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
      <span class="nv">null-value</span>
      <span class="p">(</span><span class="nf">combiner</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">filter</span> <span class="nv">a</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
                    <span class="nv">null-value</span><span class="p">)</span><span class="c1">;; if it doesn't, replace with null-value</span>
                <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nv">combiner</span>
                                     <span class="nv">filter</span>
                                     <span class="nv">null-value</span>
                                     <span class="nv">term</span>
                                     <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span>
                                     <span class="nv">next</span>
                                     <span class="nv">b</span><span class="p">))))</span>
<span class="c1">;; iterative process</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nv">combiner</span> <span class="nv">filter</span> <span class="nv">null-value</span> <span class="nv">term</span> <span class="nv">a</span> <span class="nv">next</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">filtered-accum-iter</span> <span class="nv">a</span> <span class="nv">result</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="nv">result</span>
        <span class="p">(</span><span class="nf">filtered-accum-iter</span> <span class="p">(</span><span class="nf">next</span> <span class="nv">a</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">combiner</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">filter</span> <span class="nv">a</span><span class="p">)</span>
                                          <span class="p">(</span><span class="nf">term</span> <span class="nv">a</span><span class="p">)</span>
                                          <span class="nv">null-value</span><span class="p">)</span>
                                      <span class="nv">result</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">filtered-accum-iter</span> <span class="nv">a</span> <span class="nv">null-value</span><span class="p">))</span>
</code></pre></div></div>

<ol>
  <li></li>
</ol>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">smallest-divisor</span> <span class="nv">n</span><span class="p">)</span>
    <span class="s">"Find the smallest divisor of n that is bigger than 1."</span>
    <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span> <span class="nv">test-divisor</span><span class="p">)</span>
    <span class="s">"Find divisor of n, starting from test-divisor."</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">test-divisor</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
          <span class="p">((</span><span class="nf">divides?</span> <span class="nv">test-divisor</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">test-divisor</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">find-divisor</span> <span class="nv">n</span>
                              <span class="p">(</span><span class="nb">+</span> <span class="nv">test-divisor</span> <span class="mi">1</span><span class="p">)))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">divides?</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="s">"Can b be divided by a with remainder 0."</span>
    <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)</span>
       <span class="mi">0</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prime?</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nf">smallest-divisor</span> <span class="nv">n</span><span class="p">)</span>
       <span class="nv">n</span><span class="p">))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">square-sum-primes</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nv">+</span> <span class="nv">prime?</span> <span class="mi">0</span> <span class="nv">square</span> <span class="nv">a</span> <span class="mi">1</span><span class="nv">+</span> <span class="nv">b</span><span class="p">))</span>
<span class="c1">;; running (square-sum-primes 2 15) yields 377</span>
<span class="c1">;; 377 = (+ 4 9 25 49 121 169)</span>
</code></pre></div></div>

<ol>
  <li></li>
</ol>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">gcd</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nv">a</span>
        <span class="p">(</span><span class="nb">gcd</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">identity</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
  <span class="c1">;; product of all the positive integers less than n that</span>
  <span class="c1">;; are relatively prime to n</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">product-relative-prime</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">relative-prime?</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">gcd</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">filtered-accumulate</span> <span class="nv">*</span> <span class="nv">relative-prime?</span> <span class="mi">1</span> <span class="nv">identity</span> <span class="mi">1</span> <span class="mi">1</span><span class="nv">+</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1">;; running (product-relative-prime 15) yields 896896</span>
<span class="c1">;; 896996 = (* 1 2 4 7 8 11 13 14)</span>
</code></pre></div></div>

<h2 id="134">1.34<a id="sec-1-34"></a></h2>

<p>Suppose we define the procedure</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">g</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">g</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>Then we have</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">f</span> <span class="nv">square</span><span class="p">)</span> <span class="c1">;; 4</span>
<span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">z</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">z</span> <span class="mi">1</span><span class="p">))))</span> <span class="c1">;; 6</span>
</code></pre></div></div>

<p>What happens if we (perversely) ask the interpreter to evaluate the combination <code class="language-plaintext highlighter-rouge">(f f)</code>? Explain.</p>

<p>This will be the evaluation process:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">f</span> <span class="nv">f</span><span class="p">)</span>
<span class="c1">;;|</span>
<span class="c1">;;v</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">;;|</span>
<span class="c1">;;v</span>
<span class="p">(</span><span class="nf">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, because 2 is not an applicable procedure, the interpreter is going to yield an error.</p>

<h2 id="135">1.35<a id="sec-1-35"></a></h2>

<p>Show that the golden ratio \(\phi\) (section 1.2.2) is a fixed point of the transformation \(x \mapsto 1 + 1/x\), and use this fact to compute \(\phi\) by means of the <code class="language-plaintext highlighter-rouge">fixed-point</code> procedure.</p>

<p>By definition, a fixed point of a function \(f\) is an \(x\) such that \(f(x) = x\). So, let \(x = \phi = \frac{1+\sqrt{5}}{2}\)</p>

\[\begin{align*}
f(x) &amp;= 1 + \frac{1}{x} = 1 + \frac{2}{1+\sqrt{5}} \\
&amp;= \frac{3+\sqrt{5}}{1+\sqrt{5}}\\
&amp;= \frac{(3+\sqrt{5})(\sqrt{5} - 1)}{(1+\sqrt{5})(\sqrt{5} - 1)}\\
&amp;= \frac{2\sqrt{5} + 2}{4} = \frac{1+\sqrt{5}}{2} = x = \phi
\end{align*}\]

<p>Thus, \(\phi\) is a fixed point of transformation \(x \mapsto 1+1/x\).</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">golden-ratio</span>
  <span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span>
                              <span class="p">(</span><span class="nb">/</span> <span class="mf">1.0</span> <span class="nv">x</span><span class="p">)))</span>
               <span class="mf">1.0</span><span class="p">))</span>
</code></pre></div></div>

<p>Running the above procedure yields 1.61800327868852458.</p>

<h2 id="136">1.36<a id="sec-1-36"></a></h2>

<p>Modify the <code class="language-plaintext highlighter-rouge">fixed-point</code> procedure so that it prints the sequence of approximations it generates, using the <code class="language-plaintext highlighter-rouge">newline</code> and <code class="language-plaintext highlighter-rouge">display</code> primitives shown in exercise 1.22. Then find a solution to \(x^x = 1000\) by finding a fixed point of \(x \mapsto \log(1000) / \log(x)\). (Use Schemeâs primitive <code class="language-plaintext highlighter-rouge">log</code> procedure, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start <code class="language-plaintext highlighter-rouge">fixed-point</code> with a guess of 1, as this could cause division by \(\log(1) = 0\).)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">tolerance</span> <span class="mf">0.000001</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fixed-point</span> <span class="nv">f</span> <span class="nv">first-guess</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">abs</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">))</span> <span class="nv">tolerance</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">try</span> <span class="nv">guess</span> <span class="nv">step</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display</span> <span class="nv">step</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display</span> <span class="s">": "</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display</span> <span class="nv">guess</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">next</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">guess</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">guess</span> <span class="nv">next</span><span class="p">)</span>
          <span class="nv">next</span>
          <span class="p">(</span><span class="nf">try</span> <span class="nv">next</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">step</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">try</span> <span class="nv">first-guess</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div>

<p>Then, finding a fixed point of \(x^x = 1000\):</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; without average damping</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">x-expo</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">log</span> <span class="nv">n</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">log</span> <span class="nv">x</span><span class="p">)))</span>
               <span class="mf">2.0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">average</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;; with average damping</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">x-expo-damped</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fixed-point</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">average</span> <span class="nv">x</span>
                                    <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">log</span> <span class="nv">n</span><span class="p">)</span>
                                       <span class="p">(</span><span class="nb">log</span> <span class="nv">x</span><span class="p">))))</span>
               <span class="mf">2.0</span><span class="p">))</span>
</code></pre></div></div>

<p>Results:</p>

<ol>
  <li>Running <code class="language-plaintext highlighter-rouge">(x-expo 1000)</code>, it takes 40 (starts from 0) steps to converge:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: 2.
1: 9.965784284662087
2: 3.004472209841214
3: 6.279195757507157
4: 3.759850702401539
5: 5.215843784925895
6: 4.182207192401397
7: 4.8277650983445906
8: 4.387593384662677
9: 4.671250085763899
10: 4.481403616895052
11: 4.6053657460929
12: 4.5230849678718865
13: 4.577114682047341
14: 4.541382480151454
15: 4.564903245230833
16: 4.549372679303342
17: 4.559606491913287
18: 4.552853875788271
19: 4.557305529748263
20: 4.554369064436181
21: 4.556305311532999
22: 4.555028263573554
23: 4.555870396702851
24: 4.555315001192079
25: 4.5556812635433275
26: 4.555439715736846
27: 4.555599009998291
28: 4.555493957531389
29: 4.555563237292884
30: 4.555517548417651
31: 4.555547679306398
32: 4.555527808516254
33: 4.555540912917957
34: 4.555532270803653
35: 4.555537970114198
36: 4.555534211524127
37: 4.555536690243655
38: 4.555535055574168
39: 4.5555361336081
<span class="p">;</span>Value: 4.555535422664798
</code></pre></div></div>

<ol>
  <li>Running <code class="language-plaintext highlighter-rouge">(x-expo-damped 1000)</code>, it takes 11 steps to converge:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0: 2.
1: 5.9828921423310435
2: 4.922168721308343
3: 4.628224318195455
4: 4.568346513136242
5: 4.5577305909237005
6: 4.555909809045131
7: 4.555599411610624
8: 4.5555465521473675
9: 4.555537551999825
10: 4.555536019631145
<span class="p">;</span>Value: 4.555535758730802
</code></pre></div></div>

<p>We can see that with damping, the procedure converges way faster than the version without.</p>

<h2 id="137">1.37<a id="sec-1-37"></a></h2>

<ol>
  <li>An infinite <em>continued fraction</em> is an expression of the form:</li>
</ol>

<p>[ f = \frac{N_1}{D_1 + \frac{N_2}{D_2 + \frac{N_3}{D_3 + \cdots}}} ]</p>

<p>As an example, one can show that the infinite continued fraction expansion with the \(N_i\) and \(D_i\) all equal to 1 products \(1/\phi\), where \(\phi\) is the golden ratio (described in section 1.2.2). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such as a truncationâa so-called <em>k-term finite continued fraction</em>âhas the form:</p>

<p>[ \frac{N_1}{D_1 + \frac{N_2}{\ddots + \frac{N_k}{D_k}}} ]</p>

<p>Suppose that \(n\) and \(d\) are procedures of one argument (the term index \(i\)) that return the \(N_i\) and \(D_i\) of the terms of the continued fraction. Define a procedure <code class="language-plaintext highlighter-rouge">cont-frac</code> such that evaluating <code class="language-plaintext highlighter-rouge">(cont-frac n d k)</code> computes the value of the $k$-term finite continued fraction. Check your procedure by approximating \(1/\phi\) using</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">cont-frac</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span>
           <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span>
           <span class="nv">k</span><span class="p">)</span>
</code></pre></div></div>

<p>for successive values of \(k\). How large must you make \(k\) in order to get an approximation that is accurate to 4 decimal places?</p>

<ol>
  <li>If your <code class="language-plaintext highlighter-rouge">cont-frac</code> procedure generates a recursive process, write one that generates an iterative one. If it generates an iterative process, write one that generates a recursive process.</li>
</ol>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; recursive</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">cont-frac</span> <span class="nv">n</span> <span class="nv">d</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">single-frac</span> <span class="nv">i</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">i</span> <span class="nv">k</span><span class="p">)</span> <span class="c1">;; last term</span>
        <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">i</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">i</span><span class="p">)</span> <span class="c1">;; else</span>
           <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">i</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">single-frac</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">single-frac</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1">;; iterative</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">cont-frac</span> <span class="nv">n</span> <span class="nv">d</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">cont-frac-iter</span> <span class="nv">res</span> <span class="nv">i</span><span class="p">)</span>  <span class="c1">;; cnt starts from k, res starts from zero</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">i</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">res</span><span class="p">)</span>                     <span class="c1">;; end when cnt is zero</span>
          <span class="p">((</span><span class="nb">=</span> <span class="nv">i</span> <span class="nv">k</span><span class="p">)</span> <span class="p">(</span><span class="nf">cont-frac-iter</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">res</span>
                                 <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">i</span><span class="p">)))</span>
                              <span class="p">(</span><span class="nf">-1+</span> <span class="nv">i</span><span class="p">)))</span> <span class="c1">;; first term</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">cont-frac-iter</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">i</span><span class="p">)</span>     <span class="c1">;; replace the result with its new value</span>
                              <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">i</span><span class="p">)</span>
                                 <span class="nv">res</span><span class="p">))</span>
                           <span class="p">(</span><span class="nf">-1+</span> <span class="nv">i</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">cont-frac-iter</span> <span class="mf">0.0</span> <span class="nv">k</span><span class="p">))</span>
</code></pre></div></div>

<p>Then test:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">phi</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cont-frac</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span>
           <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span>
           <span class="nv">k</span><span class="p">)</span> <span class="c1">;; using different k</span>
</code></pre></div></div>

<p>So, \(1/\phi\) is 0.61803398874. To the 4 decimal place is 0.6180. Running the <code class="language-plaintext highlighter-rouge">cont-frac</code> procedure with \(k=10\) yields .6179775280898876. While using \(k=11\) yields .6180555555555556. So the \(k\) should be at least 11 to make it accurate enough.</p>

<h2 id="138">1.38<a id="sec-1-38"></a></h2>

<p>In 1737, the Swiss mathematician Leonhard Euler published a memoir <em>De Fractionibus Continuis</em>, which included a continued fraction expansion for \(e-2\), where \(e\) is the base of the natural logarithms. In this fraction, the \(N_i\) are all 1, and the \(D_i\) are successively 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8,â¦ Write a program that uses your <code class="language-plaintext highlighter-rouge">cont-frac</code> procedure from exercise 1.37 to approximate \(e\), based on Eulerâs expansion.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8</span>
<span class="c1">;; when (remainder i 3) is 2, than the D_i is (i+1)/3 *2</span>
<span class="c1">;; else situations, D_i is 1</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">e-D</span> <span class="nv">i</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">i</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)</span>
            <span class="mi">3</span><span class="p">)</span>
         <span class="mi">2</span><span class="p">)</span>
      <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">e-approx</span> <span class="nv">k</span><span class="p">)</span> <span class="c1">;; k-term finite, the bigger k is, the more accurate the estimate</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">cont-frac</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="nv">e-D</span>
                <span class="nv">k</span><span class="p">)</span>
     <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>Running <code class="language-plaintext highlighter-rouge">(e-approx 10)</code> yields 2.7182817182817183. Running <code class="language-plaintext highlighter-rouge">(e-approx 15)</code> yields 2.718281828470584.</p>

<h2 id="139">1.39<a id="sec-1-39"></a></h2>

<p>A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:</p>

<p>[ \tan x = \frac{x}{1 - \frac{x^2}{3 - \frac{x^2}{5 - \ddots}}} ]</p>

<p>where \(x\) is radians. Define a procedure <code class="language-plaintext highlighter-rouge">(tan-cf x k)</code> that computes an approximation to the tangent function based on Lambertâs formula. \(K\) specifies the number of terms to compute, as in exercise 1.37.</p>

<p>One observation is that, we should take the minus sign into \(N_i\) to make it compatible with <code class="language-plaintext highlighter-rouge">cont-frac</code>:</p>

\[N_i = 
\begin{cases} 
x &amp;i = 1\\ 
-x^2 &amp;i = 2, 3, \cdots 
\end{cases}\]

<p>And for \(D_i\):</p>

<p>[ D_i = 2i - 1 ]</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">tan-cf</span> <span class="nv">x</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">cont-frac</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span>
               <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
                     <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span> <span class="mf">-1.0</span><span class="p">))))</span>
             <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">i</span><span class="p">)</span>
                            <span class="mf">1.0</span><span class="p">))</span>
             <span class="nv">k</span><span class="p">))</span>
</code></pre></div></div>

<p>Running this procedure with \(k=100\):</p>

<table>
  <tbody>
    <tr>
      <td>Call</td>
      <td>Result</td>
      <td>Accurate?</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(tan-cf 3.0 10)</code></td>
      <td>-.1425465438397583</td>
      <td>Y</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(tan-cf 30 10)</code></td>
      <td>3.468225849832513</td>
      <td>N</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(tan-cf 30 100)</code></td>
      <td>-6.405331196646245</td>
      <td>Y</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(tan-cf 70 100)</code></td>
      <td>1.2219599181369425</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>

<p>We notice that, the larger the radian is, the larger \(k\) required to make our approximation accurate.</p>

<h2 id="140">1.40<a id="sec-1-40"></a></h2>

<p>Define a procedure <code class="language-plaintext highlighter-rouge">cubic</code> that can be used together with the <code class="language-plaintext highlighter-rouge">newtons-method</code> procedure in expressions of the form</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">newtons-method</span> <span class="p">(</span><span class="nf">cubic</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>to approximate zeros of the cubic \(x^3 + ax^2 + bx + c\).</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">cubic</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span> <span class="nv">x</span><span class="p">)</span>
       <span class="nv">c</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">solve-cubic</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">guess</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">newtons-method</span> <span class="p">(</span><span class="nf">cubic</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">guess</span><span class="p">))</span>
</code></pre></div></div>

<p>Running results:</p>

<table>
  <tbody>
    <tr>
      <td>Call</td>
      <td>Running Results</td>
      <td>Actual Answer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(solve-cubic 6 11 6 1.0)</code></td>
      <td>-.9999999999359228</td>
      <td>-1</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(solve-cubic 6 11 6 -4)</code></td>
      <td>-2.9999999999839293</td>
      <td>-3</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">(solve-cubic 6 11 6 -2.1)</code></td>
      <td>-2.000000000000003</td>
      <td>-2</td>
    </tr>
  </tbody>
</table>

<h2 id="141">1.41<a id="sec-1-41"></a></h2>

<p>Define a procedure <code class="language-plaintext highlighter-rouge">double</code> that takes a procedure of one argument as argument and returns a procedure that applies the original procedure twice. For example, if <code class="language-plaintext highlighter-rouge">inc</code> is a procedure that adds 1 to its argument, then <code class="language-plaintext highlighter-rouge">(double inc)</code> should be a procedure that adds 2. What value is returned by</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(((</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">double</span><span class="p">))</span> <span class="nv">inc</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">inc</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">))))</span>
</code></pre></div></div>

<p>Using substitution:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(((</span><span class="nf">double</span>
   <span class="p">(</span><span class="nf">double</span> <span class="nv">double</span><span class="p">))</span>
  <span class="nv">inc</span><span class="p">)</span>
 <span class="mi">5</span><span class="p">)</span>

<span class="p">(((</span><span class="nf">double</span>
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">x</span><span class="p">))))</span>
  <span class="nv">inc</span><span class="p">)</span>
 <span class="mi">5</span><span class="p">)</span>

<span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">x</span><span class="p">)))))</span>
  <span class="nv">inc</span><span class="p">)</span>
 <span class="mi">5</span><span class="p">)</span>

<span class="p">((</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="nv">inc</span><span class="p">))))</span>
 <span class="mi">5</span><span class="p">)</span>

<span class="p">((</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">inc</span> <span class="nv">x</span><span class="p">)))))))</span>

<span class="c1">;; ....</span>
<span class="c1">;; finally it is equivalent to +16</span>
</code></pre></div></div>

<p>Thus the result should be 16+5 = 21.</p>

<p>A easier way to deduct this: <code class="language-plaintext highlighter-rouge">double</code> is nested, and finally applied to <code class="language-plaintext highlighter-rouge">inc</code>.</p>

<p>[ (2^2)^2 \times (+1) = 16 ]</p>

<p>Running it verifies this fact. The answer is 16+5 = 21.</p>

<h2 id="142">1.42<a id="sec-1-42"></a></h2>

<p>Let \(f\) and \(g\) be two one-argument functions. The <em>composition</em> \(f\) after \(g\) is defined to be the function \(x \mapsto f(g(x))\). Define a procedure <code class="language-plaintext highlighter-rouge">compose</code> that implements composition. For example, if <code class="language-plaintext highlighter-rouge">inc</code> is a procedure that adds 1 to its argument,</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">compose</span> <span class="nv">square</span> <span class="nv">inc</span><span class="p">)</span> <span class="mi">6</span><span class="p">)</span><span class="c1">;; should yield 49</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">compose</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">x</span><span class="p">))))</span>
</code></pre></div></div>

<h2 id="143">1.43<a id="sec-1-43"></a></h2>

<p>If \(f\) is a numerical function and \(n\) is a positive integer, then we can form the \(n\) th repeated application of \(f\), which is defined to be the function whose value at \(x\) is</p>

<p>[ f(f(\cdots(f(x))\cdots)) ]</p>

<p>For example, if \(f\) is the function \(x\mapsto x+1\), then the \(n\) th repeated application of \(f\) is the function \(x \mapsto x+n\). If \(f\) is the operation of squaring a number, then the \(n\) th repeated application of \(f\) is the function that raises its argument to the \(2^n\) th power. Write a procedure that takes as inputs a procedure that computes \(f\) and a positive number \(n\) and returns the procedure that computes the \(n\) th repeated application of \(f\). Your procedure should be able to be used as follows:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">repeated</span> <span class="nv">square</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; should yield 625</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">repeated</span> <span class="nv">f</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">repeat-iter</span> <span class="nv">g</span> <span class="nv">cnt</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">cnt</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">g</span><span class="p">)</span>
          <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">repeat-iter</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">x</span><span class="p">)))</span>
                             <span class="p">(</span><span class="nf">1+</span> <span class="nv">cnt</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">repeat-iter</span> <span class="nv">f</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p>It is a iterative version here. Next I will try to write a recursive one:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">repeated</span> <span class="nv">f</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">f</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">compose</span> <span class="nv">f</span>
                       <span class="p">(</span><span class="nf">repeat</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))))))</span>

<span class="c1">;; or, if we don't have compose at hand</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">repeated</span> <span class="nv">f</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">f</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">f</span> <span class="p">((</span><span class="nf">repeat</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">x</span><span class="p">))))))</span>
</code></pre></div></div>

<h2 id="144">1.44<a id="sec-1-44"></a></h2>

<p>The idea of smoothing a function is an important concept in signal processing. If \(f\) is a function and \(dx\) is some small number, then smoothed version of \(f\) is the function whose value at a point \(x\) is the average of \(f(x-dx)\), \(f(x)\), and \(f(x+dx)\). Write a procedure <code class="language-plaintext highlighter-rouge">smooth</code> that takes as input a procedure that computes \(f\) and returns a procedure that computes the smoothed \(f\). It is sometimes valuable to repeatedly smooth a function (that is smooth the smoothed function, and so on) to obtained the $n$-fold smoothed function. Show how to generate the $n$-fold smoothed function of any given function using <code class="language-plaintext highlighter-rouge">smooth</code> and <code class="language-plaintext highlighter-rouge">repeated</code> from exercise 1.43.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">dx</span> <span class="mf">0.00001</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">smooth</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">dx</span><span class="p">)))</span>
       <span class="mf">3.0</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">n-fold-smooth</span> <span class="nv">f</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(((</span><span class="nf">repeated</span> <span class="nv">smooth</span> <span class="nv">n</span><span class="p">)</span> <span class="nv">f</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
</code></pre></div></div>

<p>Running it using <code class="language-plaintext highlighter-rouge">cubic</code> from exercise 1.40 as an example:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">n-fold-smooth</span> <span class="p">(</span><span class="nf">cubic</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>Yields 1111.0000000062.</p>

<h2 id="145">1.45<a id="sec-1-45"></a></h2>

<p>We saw in section 1.3.3 that attempting to compute square roots by naively finding a fixed point of \(y \mapsto x/y\) does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped \(y \mapsto x/y^2\). Unfortunately, the process does not work for fourth rootsâa single average damp is not enough to make a fixed-point search for \(y \mapsto x/y^3\) converge. On the other hand, if we average damp twice (i.e., use the average damp of the average damp of \(y\mapsto x/y^3\)) the fixed-point search does converge.</p>

<p>Do some experiments to determine how many average damps are required to compute $n$th roots as a fixed-point search based upon repeated average damping of \(y \mapsto x/y^{n-1}\). Use this to implement a simple procedure for computing $n$th roots using <code class="language-plaintext highlighter-rouge">fixed-point</code>, <code class="language-plaintext highlighter-rouge">average-damp</code>, and the <code class="language-plaintext highlighter-rouge">repeated</code> procedure of exercise 1.43. Assume that any arithmetic operations you need are available as primitives.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">nth-root</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span>
                          <span class="p">(</span><span class="nf">nth-damp-needed</span> <span class="nv">n</span><span class="p">))</span> <span class="c1">;; how many damping needed</span>
                <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="nv">n</span> <span class="nv">x</span><span class="p">))</span>         <span class="c1">;; apply the repeated damping to the original mapsto function.</span>
               <span class="mf">1.0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">log-base</span> <span class="nv">x</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">log</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">log</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">nth-damp-needed</span> <span class="nv">n</span><span class="p">)</span>
  <span class="s">"Returns the exact number of times average-damp needed for the fixed point to converge."</span>
  <span class="p">(</span><span class="nb">floor</span> <span class="p">(</span><span class="nf">log-base</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="nv">n</span> <span class="nv">x</span><span class="p">)</span>
  <span class="s">"Gives the mapsto function for solving nth root"</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">fast-expt</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fast-expt</span> <span class="nv">b</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">even?</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nf">fast-expt</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">b</span>
                 <span class="p">(</span><span class="nf">fast-expt</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">even?</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">=</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;; some experiments I ran:</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="mi">3</span> <span class="mi">133</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="mi">4</span> <span class="mi">133</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="mi">7</span> <span class="mi">133</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="mi">8</span> <span class="mi">133</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="mi">15</span> <span class="mi">133</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">fixed-point</span> <span class="p">((</span><span class="nf">repeated</span> <span class="nv">average-damp</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">nth-root-mapsto</span> <span class="mi">16</span> <span class="mi">133</span><span class="p">))</span> <span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<p>The pattern I found from running different experiments is that: \(D = \lfloor \log n \rfloor\), where \(D\) is the required times of repeated damping needed to compute the root for $n$th roots.</p>

<h2 id="146">1.46<a id="sec-1-46"></a></h2>

<p>Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as <em>iterative improvement</em>. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess.</p>

<p>Write a procedure <code class="language-plaintext highlighter-rouge">iterative-improve</code> that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess. <code class="language-plaintext highlighter-rouge">iterative-improve</code> should return as its value a procedure that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the <code class="language-plaintext highlighter-rouge">sqrt</code> procedure of section 1.1.7 and <code class="language-plaintext highlighter-rouge">fixed-point</code> procedure of section 1.3.3 in terms of <code class="language-plaintext highlighter-rouge">iterative-improve</code>.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">iterative-improve</span> <span class="nv">good-enough?</span> <span class="nv">improve</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">first-guess</span><span class="p">)</span>
    <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">try</span> <span class="nv">guess</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">next</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">next</span><span class="p">)</span>
            <span class="nv">guess</span>
            <span class="p">(</span><span class="nf">try</span> <span class="nv">next</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">try</span> <span class="nv">first-guess</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">average</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="mf">2.0</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">close-enough?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">abs</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mf">0.00001</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">iterative-improve</span> <span class="nv">close-enough?</span>
                      <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">average</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
   <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fixed-point</span> <span class="nv">f</span> <span class="nv">first-guess</span><span class="p">)</span>
  <span class="p">((</span><span class="nf">iterative-improve</span> <span class="nv">close-enough?</span>
                      <span class="nv">f</span><span class="p">)</span>
   <span class="nv">first-guess</span><span class="p">))</span>
</code></pre></div></div>
:ET